<!DOCTYPE html>
<html lang="zh-cn" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="" />
	
	
	
	<title>AviatorScript编译执行流程 ｜ 被遗忘的博客</title>
	
    
    
    <meta name="description" content="本篇文章通过AviatorScript工程自带的一个示例，来简单说明一下AviatorScript的执行流程:
 初始化Aviator的核心数据结构 读取AviatorScript脚本内容，做语法树解析，并通过ASM翻译为java字节码，然后通过classLoader做类加载，构建Expression实例。 通过触发Exception#execute方法来触发脚本执行。  示例程序 本部分继续以下面的示例来说明，这个实例在AviatorScript的工程中可以找到:
public class RunScriptExample { public static void main(final String[] args) throws Exception { // Enable java method invocation by reflection. AviatorEvaluator.getInstance() .setFunctionMissing(JavaMethodReflectionFunctionMissing.getInstance()); // You can trry to test every script in examples folder by changing the file name. Expression exp = AviatorEvaluator.getInstance().compileScript(&amp;quot;examples/hello.av&amp;quot;); exp.execute(); } }  在这个实例程序中，AviatorEvaluator.getInstance()是单例模式的一种实现，用来获取AviatorEvaluatorInstance实例。
AviatorEvaluatorInstance初始化流程 在AviatorEvaluator中通过单例模式创建了AviatorEvaluatorInstance的实例。
public static AviatorEvaluatorInstance newInstance() { return new AviatorEvaluatorInstance(); } private static class StaticHolder { private static AviatorEvaluatorInstance INSTANCE = new AviatorEvaluatorInstance(); }  下面是AviatorEvaluatorInstance的构造函数：" />
    

    
    
    <meta name="keywords" content="JAVA, Spring, IOT, KAFKA, python, mysql" />
    

	

    <style type="text/css">
    </style>

    <link rel="shortcut icon" href="https://wenchao.ren/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://wenchao.ren/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://wenchao.ren/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://wenchao.ren/css/idea.css" />
    <script src="https://wenchao.ren/js/highlight.min.js"></script>
    <script src="https://wenchao.ren/js/highlightjs-line-numbers.min.js"></script>
    <script>hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
    </script>


    
    
</head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://wenchao.ren">
                    <span>被遗忘的博客</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title"></p>
            <div class="my_socials">
                
                
                <a href="https://github.com/xkrivzooh" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://weibo.com/AnotherRobot/home" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                <a href="https://wenchao.ren/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/aviatorscript%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/'>AviatorScript编译执行流程</a></h2>
                    </div>
                    <div class="post_content markdown"><p>本篇文章通过AviatorScript工程自带的一个示例，来简单说明一下AviatorScript的执行流程:</p>
<ul>
<li>初始化Aviator的核心数据结构</li>
<li>读取AviatorScript脚本内容，做语法树解析，并通过ASM翻译为java字节码，然后通过classLoader做类加载，构建<code>Expression</code>实例。</li>
<li>通过触发<code>Exception#execute</code>方法来触发脚本执行。</li>
</ul>
<h2 id="示例程序">示例程序</h2>
<p>本部分继续以下面的示例来说明，这个实例在AviatorScript的工程中可以找到:</p>
<pre><code class="language-java">public class RunScriptExample {

  public static void main(final String[] args) throws Exception {
    // Enable java method invocation by reflection.
    AviatorEvaluator.getInstance()
        .setFunctionMissing(JavaMethodReflectionFunctionMissing.getInstance());
    // You can trry to test every script in examples folder by changing the file name.
    Expression exp = AviatorEvaluator.getInstance().compileScript(&quot;examples/hello.av&quot;);

    exp.execute();

  }
}
</code></pre>
<p>在这个实例程序中，<code>AviatorEvaluator.getInstance()</code>是单例模式的一种实现，用来获取<code>AviatorEvaluatorInstance</code>实例。</p>
<h2 id="aviatorevaluatorinstance初始化流程">AviatorEvaluatorInstance初始化流程</h2>
<p>在<code>AviatorEvaluator</code>中通过单例模式创建了<code>AviatorEvaluatorInstance</code>的实例。</p>
<pre><code class="language-java">  public static AviatorEvaluatorInstance newInstance() {
    return new AviatorEvaluatorInstance();
  }

  private static class StaticHolder {
    private static AviatorEvaluatorInstance INSTANCE = new AviatorEvaluatorInstance();
  }
</code></pre>
<p>下面是<code>AviatorEvaluatorInstance</code>的构造函数：</p>
<pre><code class="language-java">  /**
   * Create a aviator evaluator instance.
   */
  AviatorEvaluatorInstance() {
    fillDefaultOpts();
    loadFeatureFunctions();
    loadLib();
    loadModule();
    addFunctionLoader(ClassPathConfigFunctionLoader.getInstance());
  }
</code></pre>
<p>在<code>AviatorEvaluatorInstance</code>初始化的时候主要做了几件事情：</p>
<ul>
<li>填充默认的配置参数，也就是填充AviatorEvaluatorInstance#options。它是一个<code>IdentityHashMap</code>类型的实例。
<ul>
<li>程序存在<code>Options</code>枚举列举了目前版本所支持的所有的预定义的配置参数。
<ul>
<li>目前的配置参数的值有几种类型：
<ul>
<li>boolean</li>
<li>MathContext</li>
<li>int</li>
<li>Set<Feature></li>
<li>Set&lt;Class&lt;?&raquo;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>加载所有预定义的语法特性（Syntax features）。会填充到<code>AviatorEvaluatorInstance#funcMap</code>中。语法特性集合是定义在<code>Options#FULL_FEATURE_SET</code>字段中的。
<ul>
<li>程序存在<code>Feature</code>枚举列举了目前版本所支持的所有的预定义的语法特性。</li>
</ul>
</li>
<li>加载所有的函数库
<ul>
<li>system functions</li>
<li>string functions</li>
<li>math functions</li>
<li>seq functions</li>
<li>加载内置的通过<code>aviatorscript</code>编写的函数，目前在<code>main/resources</code>目录下有一个<code>aviator.av</code>文件，里面定义了其他的一些seq functions。不过这部分的函数不光存储到上面的<code>AviatorEvaluatorInstance#funcMap</code>中，同时也存在了<code>AviatorEvaluatorInstance#internalLibFunctions</code>中，存储了2份。</li>
</ul>
</li>
<li>加载内置module
<ul>
<li>目前内置module只有一个<code>IoModule</code>。其实就是将其中的方法作为一些内置函数供以后使用。然后module存在了<code>AviatorEvaluatorInstance#moduleCache</code>中</li>
</ul>
</li>
<li>增加functionLoader。目前其实就是使用<code>ClassPathConfigFunctionLoader</code>。存储在了<code>AviatorEvaluatorInstance#functionLoaders</code>中</li>
</ul>
<h2 id="aviatorscript脚本转换为java代码">AviatorScript脚本转换为JAVA代码</h2>
<p>在示例程序RunScriptExample中，当构建完<code>AviatorEvaluatorInstance</code>实例后，开始执行:<code>Expression exp = AviatorEvaluator.getInstance().compileScript(&quot;examples/hello.av&quot;);</code>。简单说下这一行代码的作用就是读取<code>&quot;examples/hello.av&quot;</code>目录下的script文件，做语法树解析，然后通过ASM将AviatorScript语法翻译为JVM可识别的Java字节码，然后进行类加载，构建为<code>Expression</code>实例。下面说一下其中的大致执行流程。</p>
<p>其中<code>compileScript</code>函数的定义如下：</p>
<pre><code class="language-java">  /**
   * Compile a script file into expression, it doesn't cache the compiled result.
   *
   * @param file the script file path
   * @return
   */
  public Expression compileScript(final String path) throws IOException {
    return this.compileScript(path, this.cachedExpressionByDefault);
  }

  /**
   * Compile a script file into expression.
   *
   * @param file the script file path
   * @param cached whether to cached the compiled result with key is script file's absolute path.
   * @since 5.0.0
   * @return the compiled expression instance.
   */
  public Expression compileScript(final String path, final boolean cached) throws IOException {
    File file = tryFindScriptFile(path);
    return compileScript(file.getAbsolutePath(), file, cached);
  }  
</code></pre>
<p>默认情况下<code>this.cachedExpressionByDefault</code>是false，也就是不会缓存编译的结果。</p>
<p>其中的<code>tryFindScriptFile</code>的作用其实就是做文件查找和加载，代码如下：</p>
<pre><code class="language-java">  public File tryFindScriptFile(final String path) throws IOException {
    // 1. absolute path
    File file = new File(path);
    if (file.exists()) {
      return file;
    }
    // 2. from context classloader
    ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
    file = tryFindFileFromClassLoader(path, contextLoader);
    if (file != null) {
      return file;
    }
    // 3. from current class loader
    contextLoader = getClass().getClassLoader();
    file = tryFindFileFromClassLoader(path, contextLoader);
    if (file != null) {
      return file;
    }
    throw new FileNotFoundException(&quot;File not found: &quot; + path);
  }

  private File tryFindFileFromClassLoader(final String path, final ClassLoader contextLoader) {
    URL url = contextLoader.getResource(path);
    if (url != null) {
      return new File(url.getPath());
    }
    if (!path.startsWith(&quot;/&quot;)) {
      url = contextLoader.getResource(&quot;/&quot; + path);
    }
    return null;
  }  
</code></pre>
<p>他会按照如下的顺序加载：</p>
<ul>
<li>将传入的文件路径按照绝对路径加载，加载到了就返回。</li>
<li>从线程上下文的classLoader中加载，</li>
<li>从当前的classLoader中加载</li>
<li>最后还没加载到，抛出<code>FileNotFoundException</code></li>
</ul>
<p>在另外的<code>compileScript</code>重载方法中，会将上面加载到的文件内容完全读出来，然后做下一步的编译操作:</p>
<pre><code class="language-java"> /**
   * Compile a script into expression.
   *
   * @param cacheKey caching key when cached is true.
   * @param file the script file
   * @param cached whether to cache the expression instance by cacheKey.
   * @return the compiled expression instance.
   * @since 5.0.0
   * @throws IOException
   */
  public Expression compileScript(final String cacheKey, final File file, final boolean cached)
      throws IOException {
    try (InputStream in = new FileInputStream(file);
        Reader reader = new InputStreamReader(in, Charset.forName(&quot;utf-8&quot;));) {

      return compile(cacheKey, Utils.readFully(reader), file.getName(), cached);
    }
  }
</code></pre>
<p>然后在经过一层compile的重载：</p>
<pre><code class="language-java">  private Expression compile(final String cacheKey, final String expression,
      final String sourceFile, final boolean cached) {
    if (expression == null || expression.trim().length() == 0) {
      throw new CompileExpressionErrorException(&quot;Blank expression&quot;);
    }
    if (cacheKey == null || cacheKey.trim().length() == 0) {
      throw new CompileExpressionErrorException(&quot;Blank cacheKey&quot;);
    }

    if (cached) {
      FutureTask&lt;Expression&gt; existedTask = null;
      if (this.expressionLRUCache != null) {
        boolean runTask = false;
        synchronized (this.expressionLRUCache) {
          existedTask = this.expressionLRUCache.get(cacheKey);
          if (existedTask == null) {
            existedTask = newCompileTask(expression, sourceFile, cached);
            runTask = true;
            this.expressionLRUCache.put(cacheKey, existedTask);
          }
        }
        if (runTask) {
          existedTask.run();
        }
      } else {
        FutureTask&lt;Expression&gt; task = this.expressionCache.get(cacheKey);
        if (task != null) {
          return getCompiledExpression(expression, task);
        }
        task = newCompileTask(expression, sourceFile, cached);
        existedTask = this.expressionCache.putIfAbsent(cacheKey, task);
        if (existedTask == null) {
          existedTask = task;
          existedTask.run();
        }
      }
      return getCompiledExpression(cacheKey, existedTask);

    } else {
      return innerCompile(expression, sourceFile, cached);
    }

  }
</code></pre>
<p>在这一层的重载中，主要是按照是否对结果进行缓存来走不同的分支，我们先不考虑结果缓存，因此我们会直接执行:<code>innerCompile(expression, sourceFile, false)</code></p>
<p>最后就到了最核心的compile的实现了：</p>
<pre><code class="language-java">  private Expression innerCompile(final String expression, final String sourceFile,
      final boolean cached) {
    ExpressionLexer lexer = new ExpressionLexer(this, expression);
    CodeGenerator codeGenerator = newCodeGenerator(sourceFile, cached);
    ExpressionParser parser = new ExpressionParser(this, lexer, codeGenerator);
    Expression exp = parser.parse();
    if (getOptionValue(Options.TRACE_EVAL).bool) {
      ((BaseExpression) exp).setExpression(expression);
    }
    return exp;
  }
</code></pre>
<p>先明确一下此时的入参的值：</p>
<ul>
<li>expression为<code>examples/hello.av</code>文件的内容。</li>
<li>sourceFile为: hello.av</li>
<li>cached为false</li>
</ul>
<p>在这个<code>innerCompile</code>方法中，第一行是构建<code>ExpressionLexer</code>实例，第三行是构建<code>ExpressionParser</code>。其实在我看来这两个的作用基本都是一样的，就是做词法解析，将avaitorScript拆解为可以生成可执行的java代码的材料。关于这块的语法树（AST）解析，我一直觉的是个脏活累活，太恶心了。所以在本篇文章中，暂不详细分析这2个文件。后面计划安排时间专门来说。总之他们的作用就是用来生成java字节码的。</p>
<p>而方法的第二行是构建<code>CodeGenerator</code>的示例，底层是基于<code>ASM</code>实现的。指的一提的是，类似于其他开源项目，为了减少依赖冲突以及独立性的考量，直接将所需的asm工程的代码复制到项目中进行了使用。</p>
<p><code>CodeGenerator</code>使用的classLoader是<code>AviatorClassLoader</code>，同时<code>AviatorClassLoader getAviatorClassLoader(final boolean cached)</code>方法支持对classLoader的缓存，这样就不需要每次都创建一个classLoader。</p>
<p>默认缓存的classLoader是在<code>AviatorEvaluatorInstance</code>实例化时调用<code>initAviatorClassLoader()</code>方法来实现的：</p>
<pre><code class="language-java">  private AviatorClassLoader initAviatorClassLoader() {
    return AccessController.doPrivileged(new PrivilegedAction&lt;AviatorClassLoader&gt;() {

      @Override
      public AviatorClassLoader run() {
        return new AviatorClassLoader(AviatorEvaluatorInstance.class.getClassLoader());
      }

    });
  }
</code></pre>
<p>因为这篇文章是以AviatorScript中自带的<code>RunScriptExample</code>例子来说明程序执行的流程的，所以其中的<code>newCodeGenerator</code>方法会执行到<code>AviatorEvaluator.EVAL</code>分支，返回的<code>CodeGenerator</code>是<code>OptimizeCodeGenerator</code>的示例。而<code>OptimizeCodeGenerator</code>的底层其实就是<code>ASMCodeGenerator</code>。从方法命名上来看是做了一些优化，但是目前优化点在哪说实话我暂时没有看出来。</p>
<p>在<code>innerCompile</code>方法的<code>Expression exp = parser.parse();</code>这一行中，其实就是利用了<code>ExpressionLexer</code>和<code>ExpressionParser</code>做了表达式解析，然后流程会执行到<code>ExpressionParser#parse(final boolean reportErrorIfNotEOF)</code>方法的最后一行<code>return getCodeGeneratorWithTimes().getResult(true);</code>。在这个<code>getResult</code>方法中，会执行到<code>OptimizeCodeGenerator:438行public Expression getResult(final boolean unboxObject)</code>。</p>
<p>在<code>RunScriptExample</code>的实例执行过程中，会执行到OptimizeCodeGenerator的436行:</p>
<pre><code class="language-java">    if (exp == null) {
      // call asm to generate byte codes
      callASM(variables, methods, constants);
      // get result from asm
      exp = this.codeGen.getResult(unboxObject);
    }
</code></pre>
<p>其中这块就是AST解析完成，然后开始通过ASM生成java代码。在这个实例中，
变量<code>variables</code>和<code>constants</code>都是空的，只有<code>methods</code>变量有值：<code>println -&gt; {Integer@992} 1</code>。</p>
<p>而上述的2行代码，其实就是通过<code>OptimizeCodeGenerator#codeGen#classWriter</code>，借助ASM的API来进行java字节码的生成工作。而当执行到<code>ASMCodeGenerator#getResult</code>方法时：</p>
<pre><code class="language-java">@Override
public Expression getResult(final boolean unboxObject) {
  end(unboxObject);

  //此时的字节码已经生成完事了
  byte[] bytes = this.classWriter.toByteArray();
  try {
    //加载类，这个ClassDefiner中做了一下优化。
    Class&lt;?&gt; defineClass =
        ClassDefiner.defineClass(this.className, Expression.class, bytes, this.classLoader);
        //拿构造函数
    Constructor&lt;?&gt; constructor =
        defineClass.getConstructor(AviatorEvaluatorInstance.class, List.class, SymbolTable.class);
        //调用构造函数做初始化
        //this.variables.values()的值为空list
        //this.symbolTable 为：println -&gt; {Variable@1343} &quot;[type='variable',lexeme='println',index=22]&quot;
    ClassExpression exp = (ClassExpression) constructor.newInstance(this.instance,
        new ArrayList&lt;VariableMeta&gt;(this.variables.values()), this.symbolTable);
    exp.setLambdaBootstraps(this.lambdaBootstraps);
    exp.setFuncsArgs(this.funcsArgs);
    exp.setSourceFile(this.sourceFile);
    return exp;
  } catch (ExpressionRuntimeException e) {
    throw e;
  } catch (Throwable e) {
    if (e.getCause() instanceof ExpressionRuntimeException) {
      throw (ExpressionRuntimeException) e.getCause();
    }
    throw new CompileExpressionErrorException(&quot;define class error&quot;, e);
  }
}
</code></pre>
<p>此时字节码已经生成完成了。以<code>RunScriptExample</code>实例中的<code>examples/hello.av</code>文件：</p>
<pre><code class="language-shell">## examples/hello.av

println(&quot;hello, AviatorScript!&quot;);
</code></pre>
<p>为例子，上述的AviatorScript脚本生成的java字节码反编译后为：</p>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

import com.googlecode.aviator.AviatorEvaluatorInstance;
import com.googlecode.aviator.ClassExpression;
import com.googlecode.aviator.lexer.SymbolTable;
import com.googlecode.aviator.runtime.RuntimeUtils;
import com.googlecode.aviator.runtime.type.AviatorFunction;
import com.googlecode.aviator.runtime.type.AviatorString;
import com.googlecode.aviator.utils.Env;
import java.util.List;

public class Script_1620379698495_56 extends ClassExpression {
    private final AviatorFunction f0;

    public Script_1620379698495_56(AviatorEvaluatorInstance var1, List var2, SymbolTable var3) {
        super(var1, var2, var3);
        this.f0 = var1.getFunction(&quot;println&quot;, var3);
    }

    public final Object execute0(Env var1) {
        RuntimeUtils.assertNotNull(this.f0.call(var1, new AviatorString(&quot;hello, AviatorScript!&quot;, (boolean)1, (boolean)0, 3)));
        return null;
    }
}
</code></pre>
<p>这个反编译后的类名是按照一定规则生成的，主要是为了避免重复。</p>
<p>在<code>ASMCodeGenerator#getResult</code>方法时中使用<code>ClassDefiner</code>对这个类进行了加载，而这个<code>ClassDefiner</code>实现的也挺精巧的，内部做了一些优化，优先使用<code>MethodHandle#invokeExact</code>来做类加载，如果有问题才会使用<code>classLoader#defineClass</code>来做类加载。</p>
<p>类加载够，返回通过反射拿到它的构造函数并执行，对应到上面反编译后的类<code>Script_1620379698495_56</code>来说，构造函数执行后，其中的<code>f0</code>就是通过调用<code>AviatorEvaluatorInstance#getFunction</code>来获取的。在这个case中就是<code>PrintlnFunction</code>实例。最后方法返回。</p>
<p>截止到现在，<code>RunScriptExample</code>类中的<code>Expression exp = AviatorEvaluator.getInstance().compileScript(&quot;examples/hello.av&quot;);</code>这一行执行完成，</p>
<h2 id="执行翻译后的java代码">执行翻译后的JAVA代码</h2>
<p>然后通过执行<code>exp.execute();</code>触发刚刚生成的java类进行执行，对应的是<code>Script_1620379698495_56#execute0</code>方法。
在执行<code>this.f0.call(var1, new AviatorString(&quot;hello, AviatorScript!&quot;, (boolean)1, (boolean)0, 3))</code>时，调用的是<code>AviatorFunction</code>的<code>public AviatorObject call(Map&lt;String, Object&gt; env, AviatorObject arg1);</code>方法,继而执行到<code>PrintlnFunction#call</code>方法：</p>
<pre><code class="language-java"> @Override
  public AviatorObject call(Map&lt;String, Object&gt; env, AviatorObject arg1) {
    System.out.println(arg1.getValue(env));
    return AviatorNil.NIL;
  }
</code></pre>
<p>至此，<code>RunScriptExample</code>的流程执行完。</p>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://wenchao.ren/tags/aviatorscript/">AviatorScript</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "rollenholt" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span></span>
    </div>
</footer>
    <script src="https://wenchao.ren/js/jquery-3.5.1.min.js"></script>
<link href="https://wenchao.ren/css/fancybox.min.css" rel="stylesheet">
<script src="https://wenchao.ren/js/fancybox.min.js"></script>
<script src="https://wenchao.ren/js/zozo.js"></script>




</body>

</html>