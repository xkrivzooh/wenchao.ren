<!DOCTYPE html>
<html lang="zh-cn" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="" />
	
	
	
	<title>类加载器那些事儿（一） ｜ 被遗忘的博客</title>
	
    
    
    <meta name="description" content="在之前的文章《Java类的生命周期》我们谈了一下类的生命周期。 在这篇文章中，我们谈谈java的类加载器哪些事情。从下面的JVM架构图可以看到
class Loader subSystem负责管理和维护java类的生命周期的前三个阶段:
 加载 链接 初始化  当我们编写一个java的源文件后，我们对这个xxx.java编译会得到xxx.class的字节码文件，因为jvm只能运行字节码文件。为了能够使用这个class字节码文件，我们就会用到java中的ClassLoader。 而我们这篇文章就来说说java类加载器的那些事情。
ClassLoader是什么 ClassLoader顾名思义就是用来加载Class的。它负责将Class的字节码形式转换成内存形式的Class对象。
类的加载方式比较灵活，我们最常用的加载方式有下面几种：
 一种是根据类的全路径名找到相应的class文件，然后从class文件中读取文件内容； 另一种是从jar文件中读取 从网络中获取，比如早期的Applet 基于字节码生成技术生成的代理类  字节码的本质就是一个字节数组（byte[]），它有特定的复杂的内部格式。因为字节码文件有一定的格式，而且由ClassLoader进行加载，那么我们其实可以通过定制ClassLoader来实现字节码加密，原理很简单：
 加密：对java源代码进行编译得到字节码文件，然后使用某种算法对字节码文件进行加密 解密：定制的ClassLoader会先使用加密算法对应的解密算法对加密的字节码文件进行解密，然后使用在正常加载jvm标准的字节码格式文件。  3个重要的ClassLoader 在上面的JVM架构图中，我们可以看到在类的加载阶段有3个重要的ClassLoader，下面分别介绍一下这3个比较重要的ClassLoader。
启动类加载器(BootstrapClassLoader) 这个类加载器负责加载JVM运行时核心类， 将&amp;lt;JAVA_HOME&amp;gt;\lib目录下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到虚拟机内存中,这个 ClassLoader比较特殊，它是由C/C&#43;&#43;代码实现的，我们将它称之为「根加载器」。此类加载器并不继承于java.lang.ClassLoader,不能被java程序直接调用。
注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。
扩展类加载器(ExtensionClassLoader) 这个类加载器sun.misc.Launcher$ExtClassLoader由Java语言实现的，是Launcher的静态内部类, 它负责加载&amp;lt;JAVA_HOME&amp;gt;/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用使用这个类加载器。
常见的比如 swing 系列、内置的 js 引擎、xml 解析器等等都是由这个类加载器加载的， 这些库名通常以javax开头，它们的jar包位于&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录下的类库。
//ExtClassLoader类中获取路径的代码 private static File[] getExtDirs() { //加载&amp;lt;JAVA_HOME&amp;gt;/lib/ext目录中的类库 String s = System.getProperty(&amp;quot;java.ext.dirs&amp;quot;); File[] dirs; if (s != null) { StringTokenizer st = new StringTokenizer(s, File.pathSeparator); int count = st." />
    

    
    
    <meta name="keywords" content="JAVA, Spring, IOT, KAFKA, python, mysql" />
    

	

    <style type="text/css">
    </style>

    <link rel="shortcut icon" href="https://wenchao.ren/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://wenchao.ren/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://wenchao.ren/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://wenchao.ren/css/idea.css" />
    <script src="https://wenchao.ren/js/highlight.min.js"></script>
    <script src="https://wenchao.ren/js/highlightjs-line-numbers.min.js"></script>
    <script>hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
    </script>


    
    
</head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://wenchao.ren">
                    <span>被遗忘的博客</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title"></p>
            <div class="my_socials">
                
                
                <a href="https://github.com/xkrivzooh" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://weibo.com/AnotherRobot/home" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                <a href="https://wenchao.ren/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B8%80/'>类加载器那些事儿（一）</a></h2>
                    </div>
                    <div class="post_content markdown"><p>在之前的文章<a href="https://wenchao.ren/2019/02/Java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">《Java类的生命周期》</a>我们谈了一下类的生命周期。
在这篇文章中，我们谈谈java的类加载器哪些事情。从下面的JVM架构图可以看到</p>
<p><img src="http://wenchao.ren/img/2020/11/20190227210846.png" alt="JVM架构图"></p>
<p><code>class Loader subSystem</code>负责管理和维护java类的生命周期的前三个阶段:</p>
<ul>
<li>加载</li>
<li>链接</li>
<li>初始化</li>
</ul>
<p>当我们编写一个java的源文件后，我们对这个<code>xxx.java</code>编译会得到<code>xxx.class</code>的字节码文件，因为jvm只能运行字节码文件。为了能够使用这个class字节码文件，我们就会用到java中的<code>ClassLoader</code>。 而我们这篇文章就来说说java类加载器的那些事情。</p>
<h2 id="classloader是什么">ClassLoader是什么</h2>
<p><code>ClassLoader</code>顾名思义就是用来加载Class的。它负责将Class的字节码形式转换成内存形式的Class对象。</p>
<p><img src="http://wenchao.ren/img/2020/11/20190228134654.png" alt=""></p>
<p>类的加载方式比较灵活，我们最常用的加载方式有下面几种：</p>
<ul>
<li>一种是根据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；</li>
<li>另一种是从jar文件中读取</li>
<li>从网络中获取，比如早期的Applet</li>
<li>基于字节码生成技术生成的代理类</li>
</ul>
<p>字节码的本质就是一个字节数组（byte[]），它有特定的复杂的内部格式。因为字节码文件有一定的格式，而且由ClassLoader进行加载，那么我们其实可以通过定制ClassLoader来实现字节码加密，原理很简单：</p>
<ul>
<li>加密：对java源代码进行编译得到字节码文件，然后使用某种算法对字节码文件进行加密</li>
<li>解密：定制的ClassLoader会先使用加密算法对应的解密算法对加密的字节码文件进行解密，然后使用在正常加载jvm标准的字节码格式文件。</li>
</ul>
<h2 id="3个重要的classloader">3个重要的ClassLoader</h2>
<p>在上面的JVM架构图中，我们可以看到在类的加载阶段有3个重要的ClassLoader，下面分别介绍一下这3个比较重要的ClassLoader。</p>
<h3 id="启动类加载器bootstrapclassloader">启动类加载器(BootstrapClassLoader)</h3>
<p>这个类加载器负责加载JVM运行时核心类， 将<code>&lt;JAVA_HOME&gt;\lib</code>目录下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的jar包加载到虚拟机内存中,这个 ClassLoader比较特殊，它是由C/C++代码实现的，我们将它称之为「根加载器」。此类加载器并不继承于<code>java.lang.ClassLoader</code>,不能被java程序直接调用。</p>
<p>注意必由于虚拟机是按照文件名识别加载jar包的，如<code>rt.jar</code>，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</p>
<h3 id="扩展类加载器extensionclassloader">扩展类加载器(ExtensionClassLoader)</h3>
<p>这个类加载器<code>sun.misc.Launcher$ExtClassLoader</code>由Java语言实现的，是Launcher的静态内部类, 它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下或者由系统变量<code>-Djava.ext.dir</code>指定位路径中的类库，开发者可以直接使用使用这个类加载器。</p>
<p>常见的比如 swing 系列、内置的 js 引擎、xml 解析器等等都是由这个类加载器加载的， 这些库名通常以<code>javax</code>开头，它们的jar包位于<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下的类库。</p>
<pre><code class="language-java">//ExtClassLoader类中获取路径的代码
private static File[] getExtDirs() {
     //加载&lt;JAVA_HOME&gt;/lib/ext目录中的类库
     String s = System.getProperty(&quot;java.ext.dirs&quot;);
     File[] dirs;
     if (s != null) {
         StringTokenizer st =
             new StringTokenizer(s, File.pathSeparator);
         int count = st.countTokens();
         dirs = new File[count];
         for (int i = 0; i &lt; count; i++) {
             dirs[i] = new File(st.nextToken());
         }
     } else {
         dirs = new File[0];
     }
     return dirs;
 }
</code></pre>
<h3 id="应用程序类加载器appclassloader">应用程序类加载器(AppClassLoader)</h3>
<p><code>sun.misc.Launcher$AppClassLoader</code>才是直接面向我们用户的加载器，它负责加载系统类路径<code>java -classpath</code>或<code>-Djava.class.path</code>指定路径下的类库，也就是我们经常用到的classpath路径jar包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。开发者可以直接使用系统类加载器, 这个类加载器是CLassLoader中的<code>getSystemClassLoader()</code>方法的返回值, 所以也称为系统类加载器.一般情况下这就是系统默认的类加载器. 当我们的 main 方法执行的时候，这第一个用户类的加载器就是<code>AppClassLoader</code>。</p>
<p>那些位于网络上静态文件服务器提供的jar包和class文件，jdk 内置了一个<code>URLClassLoader</code>，用户只需要传递规范的网络路径给构造器,就可以使用 URLClassLoader 来加载远程类库了。<code>URLClassLoader</code>不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。</p>
<p><code>ExtensionClassLoader</code> 和 <code>AppClassLoader</code>都是<code>URLClassLoader</code>的子类，它们都是从本地文件系统里加载类库。</p>
<h2 id="classloader之间的层级关系">ClassLoader之间的层级关系</h2>
<pre><code class="language-java">public abstract class Class {

   // Initialized in JVM not by private constructor
   // This field is filtered from reflection access, i.e. getDeclaredField
   // will throw NoSuchFieldException
   private final ClassLoader classLoader;
   }
public abstract class ClassLoader {
   // The parent class loader for delegation
   // Note: VM hardcoded the offset of this field, thus all new fields
   // must be added *after* it.
   private final ClassLoader parent;
   }
</code></pre>
<p>我们翻看jdk的代码会发现：</p>
<ul>
<li>ClassLoader是一个抽象类</li>
<li>每一个ClassLoader都有一个父ClassLoader的引用</li>
<li>每一个Class中都有一个标记自己是哪个ClassLoader加载的属性</li>
</ul>
<p>我们编写下面的测试代码：</p>
<pre><code class="language-java">public class TestClassLoader {

    public static void main(String[] args) {
        ClassLoader loader = TestClassLoader.class.getClassLoader();
        System.out.println(loader.toString());
        System.out.println(loader.getParent().toString());
        System.out.println(loader.getParent().getParent());
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>sun.misc.Launcher$AppClassLoader@500c05c2
sun.misc.Launcher$ExtClassLoader@454e2c9c
null
</code></pre>
<p>从日志输出我们可以看出，我们的<code>TestClassLoader</code>是由<code>AppClassLoader</code>加载的，<code>AppClassLoader</code>的父ClassLoader是<code>ExtClassLoader</code>，而<code>ExtClassLoader</code>的
父ClassLoader是null，jvm约定当<code>ClassLoader#getParent()</code>返回时null的话,就默认使用启动类加载器作为父加载器.下面是ClassLoader.java中的关于getParent方法的描述：</p>
<pre><code class="language-java">    /**
     * Returns the parent class loader for delegation. Some implementations may
     * use &lt;tt&gt;null&lt;/tt&gt; to represent the bootstrap class loader. This method
     * will return &lt;tt&gt;null&lt;/tt&gt; in such implementations if this class loader's
     * parent is the bootstrap class loader.
     *
     * &lt;p&gt; If a security manager is present, and the invoker's class loader is
     * not &lt;tt&gt;null&lt;/tt&gt; and is not an ancestor of this class loader, then this
     * method invokes the security manager's {@link
     * SecurityManager#checkPermission(java.security.Permission)
     * &lt;tt&gt;checkPermission&lt;/tt&gt;} method with a {@link
     * RuntimePermission#RuntimePermission(String)
     * &lt;tt&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/tt&gt;} permission to verify
     * access to the parent class loader is permitted.  If not, a
     * &lt;tt&gt;SecurityException&lt;/tt&gt; will be thrown.  &lt;/p&gt;
     *
     * @return  The parent &lt;tt&gt;ClassLoader&lt;/tt&gt;
     *
     * @throws  SecurityException
     *          If a security manager exists and its &lt;tt&gt;checkPermission&lt;/tt&gt;
     *          method doesn't allow access to this class loader's parent class
     *          loader.
     *
     * @since  1.2
     */
    @CallerSensitive
    public final ClassLoader getParent() {
        if (parent == null)
            return null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Check access to the parent class loader
            // If the caller's class loader is same as this class loader,
            // permission check is performed.
            checkClassLoaderPermission(parent, Reflection.getCallerClass());
        }
        return parent;
    }
</code></pre>
<p>因此我们可以给出ClassLoader的继承关系图：</p>
<p><img src="http://wenchao.ren/img/2020/11/20190228135113.png" alt=""></p>
<h2 id="双亲委派模型">双亲委派模型</h2>
<p>程序在运行过程中，遇到了一个未知的类，它会选择哪个 ClassLoader 来加载它呢？</p>
<p>虚拟机的策略是: <strong>使用调用者Class对象的ClassLoader来加载当前未知的类。</strong></p>
<p>何为调用者 Class 对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者 Class对象。前面我们提到每个Class对象里面都有一个 classLoader 属性记录了当前的类是由谁来加载的。</p>
<p>但是在加载的过程中，并不是直接加载的，而是会有一个层级查找关系在，这也就是所谓的「双亲委派模型」。</p>
<p>我们可以看一下<code>ClassLoader</code>的源代码来确认这一点：</p>
<pre><code class="language-java"> /**
     * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.
     * This method searches for classes in the same manner as the {@link
     * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
     * machine to resolve class references.  Invoking this method is equivalent
     * to invoking {@link #loadClass(String, boolean) &lt;tt&gt;loadClass(name,
     * false)&lt;/tt&gt;}.
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
     *
     * @throws  ClassNotFoundException
     *          If the class was not found
     */
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    
     /**
     * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The
     * default implementation of this method searches for classes in the
     * following order:
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
     *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;} method
     *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class
     *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
     *   class.  &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; If the class was found using the above steps, and the
     * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the {@link
     * #resolveClass(Class)} method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.
     *
     * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override {@link
     * #findClass(String)}, rather than this method.  &lt;/p&gt;
     *
     * &lt;p&gt; Unless overridden, this method synchronizes on the result of
     * {@link #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;} method
     * during the entire class loading process.
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @param  resolve
     *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class
     *
     * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
     *
     * @throws  ClassNotFoundException
     *          If the class could not be found
     */
    protected Class&lt;?&gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
</code></pre>
<p>从上面的代码我们就可以看到<code>protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException</code>函数实现了「双亲委派」。简单描述如下:</p>
<ul>
<li>检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li>
<li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</li>
<li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</li>
</ul>
<p>换句话说，<strong>如果自定义类加载器，就必须重写findClass方法！</strong></p>
<p>「双亲委派模型」是一种组织类加载器之间关系的一种规范,他的工作原理是:
<code>如果一个类加载器收到了类加载的请求,它不会自己去尝试加载这个类,而是把这个请求委派给父类加载器去完成,这样层层递进,最终所有的加载请求都被传到最顶层的启动类加载器中,只有当父类加载器无法完成这个加载请求(它的搜索范围内没有找到所需的类)时,才会交给子类加载器去尝试加载.</code></p>
<p><img src="http://wenchao.ren/img/2020/11/20190228135220.png" alt=""></p>
<p>从上面的分析我们可以知道：一般情况下，我们编写的java代码所有延迟加载的类都会由初始调用main方法的这个ClassLoader全全负责，它就是<code>AppClassLoader</code>。</p>
<h3 id="为什么需要双亲委派模型">为什么需要双亲委派模型</h3>
<p>比如<code>java.lang.Object</code>,它存放在<code>\jre\lib\rt.jar</code>中,它是所有java类的父类,因此无论哪个类加载都要加载这个类,最终所有的加载请求都汇总到顶层的启动类加载器中,因此<code>Object</code>类会由启动类加载器来加载,所以加载的都是同一个类,如果不使用双亲委派模型,由各个类加载器自行去加载的话,系统中就会出现不止一个<code>Object</code>类,应用程序就会全乱了</p>
<p>因为<strong>在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。</strong></p>
<p>举个简单例子：</p>
<p>ClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。</p>
<p>这样的好处是: <strong>java类随着它的类加载器一起具备了带有优先级的层次关系。</strong></p>
<p>双亲委派规则可能会变成三亲委派，四亲委派，取决于你使用的父加载器是谁，它会一直递归委派到根加载器。只是一般我们习惯称为「双亲委派」。</p>
<h2 id="延迟加载">延迟加载</h2>
<p>JVM具体什么加载类，需要按照jvm的实现来说的。不过我们平时用的<code>Hotspot</code>虚拟机，运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。</p>
<h2 id="classloader的相关核心方法">ClassLoader的相关核心方法</h2>
<h3 id="loadclass">loadClass()</h3>
<p><code>loadClass()</code>方法是加载目标类的入口，在这个方法内部实现了「双亲委派模型」。它首先会查找当前 ClassLoader以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用<code>findClass()</code> 让自定义加载器自己来加载目标类。ClassLoader 的<code>findClass()</code>方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用<code>defineClass()</code>方法将字节码转换成Class对象。</p>
<p>下面这个图还是画的比较形象的：</p>
<p><img src="http://wenchao.ren/img/2020/11/20190228135927.png" alt=""></p>
<p><code>ClassLoader.loadClass()</code>这是一个实例方法,需要一个ClassLoader对象来调用该方法,该方法将Class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化.该方法因为需要得到一个ClassLoader对象,所以可以根据需要指定使用哪个类加载器.</p>
<pre><code class="language-java">ClassLoader cl= …….;
cl.loadClass(“com.wang.HelloWorld”);
</code></pre>
<p>提到这个<code>ClassLoader.loadClass()</code>方法，一般就需要提一下<code>Class</code>类的<code>forName</code>方法。</p>
<h4 id="classforname">Class.forname()</h4>
<p><code>Class.forname()</code>:是一个静态方法, 根据传入的类的全限定名返回一个Class对象.该方法在将Class文件加载到内存的同时,会执行类的初始化：</p>
<pre><code class="language-java">/**
     * Returns the {@code Class} object associated with the class or
     * interface with the given string name.  Invoking this method is
     * equivalent to:
     *
     * &lt;blockquote&gt;
     *  {@code Class.forName(className, true, currentLoader)}
     * &lt;/blockquote&gt;
     *
     * where {@code currentLoader} denotes the defining class loader of
     * the current class.
     *
     * &lt;p&gt; For example, the following code fragment returns the
     * runtime {@code Class} descriptor for the class named
     * {@code java.lang.Thread}:
     *
     * &lt;blockquote&gt;
     *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
     * &lt;/blockquote&gt;
     * &lt;p&gt;
     * A call to {@code forName(&quot;X&quot;)} causes the class named
     * {@code X} to be initialized.
     *
     * @param      className   the fully qualified name of the desired class.
     * @return     the {@code Class} object for the class with the
     *             specified name.
     * @exception LinkageError if the linkage fails
     * @exception ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * @exception ClassNotFoundException if the class cannot be located
     */
    @CallerSensitive
    public static Class&lt;?&gt; forName(String className)
                throws ClassNotFoundException {
        Class&lt;?&gt; caller = Reflection.getCallerClass();
        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
    }
</code></pre>
<p>比如当我们在使用jdbc驱动时，经常会使用 Class.forName 方法来动态加载驱动类。</p>
<pre><code class="language-java">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
</code></pre>
<p>其原理是 mysql 驱动的Driver类里有一个静态代码块，它会在 Driver 类被加载的时候执行。这个静态代码块会将 mysql 驱动实例注册到全局的 jdbc 驱动管理器里。</p>
<pre><code class="language-java">class Driver {
  static {
    try {
       java.sql.DriverManager.registerDriver(new Driver());
    } catch (SQLException E) {
       throw new RuntimeException(&quot;Can't register driver!&quot;);
    }
  }
  ...
}
</code></pre>
<p><code>forName</code>方法同样也是使用调用者Class对象的ClassLoader来加载目标类。不过 forName还提供了多参数版本，可以指定使用哪个ClassLoader来加载:</p>
<pre><code class="language-java">/**
     * Returns the {@code Class} object associated with the class or
     * interface with the given string name, using the given class loader.
     * Given the fully qualified name for a class or interface (in the same
     * format returned by {@code getName}) this method attempts to
     * locate, load, and link the class or interface.  The specified class
     * loader is used to load the class or interface.  If the parameter
     * {@code loader} is null, the class is loaded through the bootstrap
     * class loader.  The class is initialized only if the
     * {@code initialize} parameter is {@code true} and if it has
     * not been initialized earlier.
     *
     * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
     * will be made to locate a user-defined class in the unnamed package whose
     * name is {@code name}. Therefore, this method cannot be used to
     * obtain any of the {@code Class} objects representing primitive
     * types or void.
     *
     * &lt;p&gt; If {@code name} denotes an array class, the component type of
     * the array class is loaded but not initialized.
     *
     * &lt;p&gt; For example, in an instance method the expression:
     *
     * &lt;blockquote&gt;
     *  {@code Class.forName(&quot;Foo&quot;)}
     * &lt;/blockquote&gt;
     *
     * is equivalent to:
     *
     * &lt;blockquote&gt;
     *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
     * &lt;/blockquote&gt;
     *
     * Note that this method throws errors related to loading, linking or
     * initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The
     * Java Language Specification&lt;/em&gt;.
     * Note that this method does not check whether the requested class
     * is accessible to its caller.
     *
     * &lt;p&gt; If the {@code loader} is {@code null}, and a security
     * manager is present, and the caller's class loader is not null, then this
     * method calls the security manager's {@code checkPermission} method
     * with a {@code RuntimePermission(&quot;getClassLoader&quot;)} permission to
     * ensure it's ok to access the bootstrap class loader.
     *
     * @param name       fully qualified name of the desired class
     * @param initialize if {@code true} the class will be initialized.
     *                   See Section 12.4 of &lt;em&gt;The Java Language Specification&lt;/em&gt;.
     * @param loader     class loader from which the class must be loaded
     * @return           class object representing the desired class
     *
     * @exception LinkageError if the linkage fails
     * @exception ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * @exception ClassNotFoundException if the class cannot be located by
     *            the specified class loader
     *
     * @see       java.lang.Class#forName(String)
     * @see       java.lang.ClassLoader
     * @since     1.2
     */
    @CallerSensitive
    public static Class&lt;?&gt; forName(String name, boolean initialize,
                                   ClassLoader loader)
        throws ClassNotFoundException
    {
        Class&lt;?&gt; caller = null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Reflective call to get caller class is only needed if a security manager
            // is present.  Avoid the overhead of making this call otherwise.
            caller = Reflection.getCallerClass();
            if (sun.misc.VM.isSystemDomainLoader(loader)) {
                ClassLoader ccl = ClassLoader.getClassLoader(caller);
                if (!sun.misc.VM.isSystemDomainLoader(ccl)) {
                    sm.checkPermission(
                        SecurityConstants.GET_CLASSLOADER_PERMISSION);
                }
            }
        }
        return forName0(name, initialize, loader, caller);
    }

</code></pre>
<p>通过这种形式的<code>forName</code>方法可以突破内置加载器的限制，通过使用自定类加载器允许我们自由加载其它任意来源的类库。根据ClassLoader的传递性，目标类库传递引用到的其它类库也将会使用自定义加载器加载。</p>
<p><code>Class.forName</code>和<code>ClassLoader.loadClass</code>都可以用来加载目标类，它们之间有一个小小的区别，那就是<code>Class.forName()</code>方法可以获取原生类型的Class，而<code>ClassLoader.loadClass()</code>则会报错:</p>
<pre><code class="language-java">Class&lt;?&gt; x = Class.forName(&quot;[I&quot;);
System.out.println(x);

x = ClassLoader.getSystemClassLoader().loadClass(&quot;[I&quot;);
System.out.println(x);

---------------------
class [I

Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: [I
</code></pre>
<h3 id="findclass">findClass()</h3>
<p>在上面的「双亲委派模型」小节中，我们从<code>ClassLoader</code>类的源代码分析了，<code>loadClass()</code>方法在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的<code>findeClass()</code>函数, 这样就可以保证自定义的类加载器也符合「双亲委派」。</p>
<p>如果想实现自定义的ClassLoader，那么必须实现<code>findClass()</code>方法，而<code>ClassLoader</code>中的默认实现为直接抛出<code>ClassNotFoundException</code>异常：</p>
<pre><code class="language-java">  /**
     * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.
     * This method should be overridden by class loader implementations that
     * follow the delegation model for loading classes, and will be invoked by
     * the {@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;} method after checking the
     * parent class loader for the requested class.  The default implementation
     * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
     *
     * @throws  ClassNotFoundException
     *          If the class could not be found
     *
     * @since  1.2
     */
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
</code></pre>
<h3 id="defineclassbyte-b-int-off-int-len">defineClass(byte[] b, int off, int len)</h3>
<p><code>defineClass()</code>方法是用来将byte字节流解析成JVM能够识别的Class对象。在ClassLoader中已实现该方法逻辑，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象，<code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用。</p>
<p>一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的<code>Class</code>对象，简单例子如下：</p>
<pre><code class="language-java">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
      // 获取类的字节数组
      byte[] classData = getClassData(name);  
      if (classData == null) {
          throw new ClassNotFoundException();
      } else {
          //使用defineClass生成class对象
          return defineClass(name, classData, 0, classData.length);
      }
  }
</code></pre>
<p>在下面的「自定义类加载器」小节中也会介绍这个方法的使用。</p>
<p>需要注意的是，<strong>如果直接调用defineClass()方法生成类的Class对象，这个类的Class对象并没有解析(也可以理解为链接阶段，毕竟解析是链接的最后一步)，其解析操作需要等待初始化阶段进行。</strong></p>
<p>关于java类的生命周期，如果不了解的话，建议看看之前的文章<a href="https://wenchao.ren/2019/02/Java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">《Java类的生命周期》</a>。</p>
<h3 id="resolveclassclass-c">resolveClass(Class≺?≻ c)</h3>
<p>使用该方法可以使用类的<code>Class</code>对象创建完成也同时被<a href="https://wenchao.ren/2019/02/Java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#%E9%93%BE%E6%8E%A5">解析</a>。</p>
<p>上述4个方法是<code>ClassLoader</code>类中的比较重要的方法，也是我们可能会经常用到的方法。</p>
<p><code>SercureClassLoader</code>扩展了<code>ClassLoader</code>，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类<code>URLClassLoader</code>有所关联.</p>
<p>前面说过，<code>ClassLoader</code>是一个抽象类，很多方法是空的没有实现，比如 <code>findClass()、findResource()</code>等。而<code>URLClassLoader</code>这个实现类为这些方法提供了具体的实现，并新增了URLClassPath类协助取得Class字节码流等功能，在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p><img src="http://wenchao.ren/img/2020/11/20190228141220.png" alt=""></p>
<h2 id="class文件的显示加载与隐式加载的概念">class文件的显示加载与隐式加载的概念</h2>
<ul>
<li><strong>显示加载</strong> 指的是在代码中通过调用ClassLoader加载class对象，如直接使用<code>Class.forName(name)</code>或<code>this.getClass().getClassLoader().loadClass()</code>加载class对象。</li>
<li><strong>隐式加载</strong>则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>
</ul>
<h2 id="自定义类加载器">自定义类加载器</h2>
<p>下面写一个简单的自定义类加载的例子</p>
<p>首先我们编写一个简单的java类，这个类就是后面需要被我们的自定义类加载器加载的类：</p>
<pre><code class="language-java">package xyz.xkrivzooh;

public class HelloWorld {

	public void sayHello() {
		System.out.println(&quot;hello &quot; + this.getClass().getClassLoader().toString());
	}
}
</code></pre>
<p>我们使用javac编译后，将得到的<code>HelloWorld.class</code>文件。此处我们想一下，如果我们把这个字节码文件放置在zai当前的项目中的话，那么根据「双亲委派模型」可知这个字节码文件将会被<code>sun.misc.Launcher$AppClassLoader</code>类加载器加载，为了让我们自定义的类加载器加载，我们把<code>HelloWorld.class</code>文件放入到其他目录。</p>
<pre><code>~ » tree xyz
xyz
└── xkrivzooh
    └── HelloWorld.class
</code></pre>
<p>然后编写我们自定义的类加载器：</p>
<pre><code class="language-java">package xyz.xkrivzooh;

import java.io.File;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Paths;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;

public class CustomerClassLoader extends ClassLoader {

	private final String classPath;

	public CustomerClassLoader(String classPath) {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(classPath));
		this.classPath = classPath;
	}

	@Override
	protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(name));
		try {
			String path = name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);
			byte[] bytes = Files.readAllBytes(Paths.get(classPath + File.separator + path + &quot;.class&quot;));
			return defineClass(name, bytes, 0, bytes.length);
		}
		catch (Exception e) {
			throw new ClassNotFoundException(e.getMessage(), e);
		}
	}

	public static void main(String[] args) throws Exception{
		CustomerClassLoader customerClassLoader = new CustomerClassLoader(&quot;/Users/rollenholt&quot;);
		Class&lt;?&gt; aClass = customerClassLoader.loadClass(&quot;xyz.xkrivzooh.HelloWorld&quot;);
		Object instance = aClass.newInstance();
		Method sayHello = aClass.getDeclaredMethod(&quot;sayHello&quot;, null);
		sayHello.invoke(instance, null);
	}
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-java">hello xyz.xkrivzooh.CustomerClassLoader@4d405ef7
</code></pre>
<p>从上的例子我们可以看出，我们自定义的类加载器运行是没问题的。</p>
<p><strong>我们平时在自定义类加载器的时候需要注意的是不要轻易的去破坏双亲委派模型，也就是不要去覆盖loadClass方法，除非你明确知道你在做什么</strong></p>
<p>因为这样就可以导致导致自定义加载器无法加载内置的核心类库。在使用自定义加载器时，要明确好它的父加载器是谁，将父加载器通过子类的构造器传入。如果父类加载器是 null，那就表示父加载器是「根加载器」<code>BootstrapClassLoader</code>。</p>
<pre><code class="language-java">    /**
     * Creates a new class loader using the specified parent class loader for
     * delegation.
     *
     * &lt;p&gt; If there is a security manager, its {@link
     * SecurityManager#checkCreateClassLoader()
     * &lt;tt&gt;checkCreateClassLoader&lt;/tt&gt;} method is invoked.  This may result in
     * a security exception.  &lt;/p&gt;
     *
     * @param  parent
     *         The parent class loader
     *
     * @throws  SecurityException
     *          If a security manager exists and its
     *          &lt;tt&gt;checkCreateClassLoader&lt;/tt&gt; method doesn't allow creation
     *          of a new class loader.
     *
     * @since  1.2
     */
    protected ClassLoader(ClassLoader parent) {
        this(checkCreateClassLoader(), parent);
    }
</code></pre>
<h2 id="钻石依赖">钻石依赖</h2>
<p>项目管理上有一个著名的概念叫着「钻石依赖」，是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突。</p>
<p><img src="http://wenchao.ren/img/2020/11/20190228141539.png" alt=""></p>
<p><code>maven</code>是这样解决钻石依赖的: 它会从多个冲突的版本中选择一个来使用，如果不同的版本之间兼容性很糟糕，那么程序将无法正常编译运行。Maven 这种形式叫「扁平化」依赖管理。</p>
<p><strong>使用ClassLoader可以解决钻石依赖问题。不同版本的软件包使用不同的 ClassLoader 来加载，位于不同ClassLoader中名称一样的类实际上是不同的类。</strong></p>
<p>我们通过下面的代码来验证这个问题：</p>
<p>首先准备下面的环境：</p>
<pre><code class="language-java">~/xyz/xkrivzooh » tree .
.
├── v1
│   ├── Test.class
│   └── Test.java
└── v2
    ├── Test.class
    └── Test.java

2 directories, 4 files
------------------------------------------------------------
~/xyz/xkrivzooh » cat v1/Test.java

public class Test {
	public void sayHello() {
		System.out.println(&quot;v1&quot;);
	}
}

------------------------------------------------------------
~/xyz/xkrivzooh » cat v2/Test.java

public class Test {
	public void sayHello() {
		System.out.println(&quot;v2&quot;);
	}
}

------------------------------------------------------------
</code></pre>
<p>然后使用测试代码：</p>
<pre><code class="language-java">package xyz.xkrivzooh;

import java.net.URL;
import java.net.URLClassLoader;

public class Test {
	public static void main(String[] args) throws Exception {

		String dir1 = &quot;file:///Users/rollenholt/xyz/xkrivzooh/v1/&quot;;
		String dir2 = &quot;file:///Users/rollenholt/xyz/xkrivzooh/v2/&quot;;
		URLClassLoader classLoader1 = new URLClassLoader(new URL[] {new URL(dir1)});
		URLClassLoader classLoader2 = new URLClassLoader(new URL[] {new URL(dir2)});

		Class&lt;?&gt; aClass1 = classLoader1.loadClass(&quot;Test&quot;);
		Object instance1 = aClass1.newInstance();
		aClass1.getDeclaredMethod(&quot;sayHello&quot;, null).invoke(instance1, null);

		Class&lt;?&gt; aClass2 = classLoader2.loadClass(&quot;Test&quot;);
		Object instance2 = aClass2.newInstance();
		aClass2.getDeclaredMethod(&quot;sayHello&quot;, null).invoke(instance2, null);

		System.out.println(aClass1.equals(aClass2));
		System.out.println(instance1.equals(instance2));


		URLClassLoader classLoader3 = new URLClassLoader(new URL[] {new URL(dir1)});
		Class&lt;?&gt; aClass3 = classLoader3.loadClass(&quot;Test&quot;);
		Object instance3 = aClass3.newInstance();
		aClass3.getDeclaredMethod(&quot;sayHello&quot;, null).invoke(instance3, null);

		System.out.println(aClass3.equals(aClass1));
		System.out.println(instance3.equals(instance1));
	}
}
</code></pre>
<p>程序运行输出：</p>
<pre><code class="language-java">v1
v2
false
false
v1
false
false
</code></pre>
<p>我们还可以让两个不同版本的Test类实现同一个接口，这样可以避免使用反射的方式来调用Test类里面的方法。</p>
<pre><code class="language-java">Class&lt;?&gt; aClass = classLoader1.loadClass(&quot;Test&quot;);
SomeInterface inter1 = (SomeInterface)aClass.getConstructor().newInstance();
inter1.sayHello()
</code></pre>
<p>ClassLoader固然可以解决依赖冲突问题，不过它也限制了不同软件包的操作界面必须使用反射或接口的方式进行动态调用。Maven没有这种限制，它依赖于虚拟机的默认懒惰加载策略，运行过程中如果没有显示使用定制的ClassLoader，那么从头到尾都是在使用AppClassLoader，而不同版本的同名类必须使用不同的ClassLoader加载，所以Maven不能完美解决钻石依赖。</p>
<p>蚂蚁金服开源的sofa-ark其实就是采用ClassLoader的方式来做类隔离的。</p>
<h2 id="threadcontextclassloader">Thread.contextClassLoader</h2>
<pre><code class="language-java">  /**
     * Returns the context ClassLoader for this Thread. The context
     * ClassLoader is provided by the creator of the thread for use
     * by code running in this thread when loading classes and resources.
     * If not {@linkplain #setContextClassLoader set}, the default is the
     * ClassLoader context of the parent Thread. The context ClassLoader of the
     * primordial thread is typically set to the class loader used to load the
     * application.
     *
     * &lt;p&gt;If a security manager is present, and the invoker's class loader is not
     * {@code null} and is not the same as or an ancestor of the context class
     * loader, then this method invokes the security manager's {@link
     * SecurityManager#checkPermission(java.security.Permission) checkPermission}
     * method with a {@link RuntimePermission RuntimePermission}{@code
     * (&quot;getClassLoader&quot;)} permission to verify that retrieval of the context
     * class loader is permitted.
     *
     * @return  the context ClassLoader for this Thread, or {@code null}
     *          indicating the system class loader (or, failing that, the
     *          bootstrap class loader)
     *
     * @throws  SecurityException
     *          if the current thread cannot get the context ClassLoader
     *
     * @since 1.2
     */
    @CallerSensitive
    public ClassLoader getContextClassLoader() {
        if (contextClassLoader == null)
            return null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            ClassLoader.checkClassLoaderPermission(contextClassLoader,
                                                   Reflection.getCallerClass());
        }
        return contextClassLoader;
    }
</code></pre>
<p>Thread.contextClassLoader「线程上下文类加载器」,从方法的描述我们可以知道，线程的<code>contextClassLoader</code>是从父线程那里继承过来的，所谓父线程就是创建了当前线程的线程。程序启动时的<code>main</code>线程的contextClassLoader 就是<code>AppClassLoader</code>。这意味着如果没有人工去设置，那么所有的线程的contextClassLoader都是<code>AppClassLoader</code>。它可以做到跨线程共享类，只要它们共享同一个 contextClassLoader。父子线程之间会自动传contextClassLoader，所以共享起来将是自动化的。如果不同的线程使用不同的 contextClassLoader，那么不同的线程使用的类就可以隔离开来。</p>
<h2 id="总结">总结</h2>
<p>但是如果仅仅把<code>ClassLoader</code>当成一个将字节码形式的class转为内存形式的Class对象的工具的话有点狭义：他不仅仅是一个转换工具，他也相当于一个类的容器，或者叫命名空间可以起到「类隔离」的作用。位于同一个ClassLoader 里面的类名是唯一的，不同的ClassLoader可以持有同名的类。</p>
<p>同时通过「双亲委派模型」，不同的ClassLoader之间相互合作，形成一个层级关系。parent具有更高的加载优先级。除此之外，parent还表达了一种共享关系，当多个子ClassLoader共享同一个parent时，那么这个parent里面包含的类可以认为是所有子ClassLoader共享的。这也是为什么<code>BootstrapClassLoader</code>被所有的类加载器视为最顶层的加载器，JVM核心类库自然应该被共享。</p>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://wenchao.ren/tags/java/">java</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "rollenholt" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span></span>
    </div>
</footer>
    <script src="https://wenchao.ren/js/jquery-3.5.1.min.js"></script>
<link href="https://wenchao.ren/css/fancybox.min.css" rel="stylesheet">
<script src="https://wenchao.ren/js/fancybox.min.js"></script>
<script src="https://wenchao.ren/js/zozo.js"></script>




</body>

</html>