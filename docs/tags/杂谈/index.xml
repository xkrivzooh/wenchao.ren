<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂谈 on 被遗忘的博客</title>
    <link>https://wenchao.ren/tags/%E6%9D%82%E8%B0%88/</link>
    <description>Recent content in 杂谈 on 被遗忘的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 23 Apr 2021 14:11:09 +0800</lastBuildDate><atom:link href="https://wenchao.ren/tags/%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>hugo新写的文章展示不出来</title>
      <link>https://wenchao.ren/posts/hugo%E6%96%B0%E5%86%99%E7%9A%84%E6%96%87%E7%AB%A0%E5%B1%95%E7%A4%BA%E4%B8%8D%E5%87%BA%E6%9D%A5/</link>
      <pubDate>Fri, 23 Apr 2021 14:11:09 +0800</pubDate>
      
      <guid>https://wenchao.ren/posts/hugo%E6%96%B0%E5%86%99%E7%9A%84%E6%96%87%E7%AB%A0%E5%B1%95%E7%A4%BA%E4%B8%8D%E5%87%BA%E6%9D%A5/</guid>
      <description>最近因为在公司的笔记本上写博文，所以并不打算采用在terminal中使用hugo new的方式来生成新的博文模板，而是自己在vs code中 编写好之后然后手动在github的网页新增文件触发github actions的执行然后部署到vps上。
遇到的问题 然后发现自己新写的文章居然展示不出来。排查了一下博文前面的头信息：
--- title: &amp;quot;hugo新写的文章展示不出来&amp;quot; date: 2021-04-23T11:11:09+08:00 draft: false tags: [&#39;杂谈&#39;] ---  发现这些头信息的格式写的并没有问题，即便这个时间也没有任何的问题。
解决过程 后来在网上搜到了这个文章：Hugo Post Missing (Hugo 博客文章缺失问题)。文章中提到了：
 Hugo 是否会渲染一篇博文依赖该文章的发布时间。如果一个博文的发布时间比 Hugo 构建当前站点的时间还要晚，也就是 Hugo 认为博文的发布时间在未来，就不会渲染该篇博文。前面没有写时区的博文，就是被 Hugo 认为发布时间还未到，所以没有渲染出来。
 解决办法  第一种最简单的办法是修改文章头信息中的date时间为过去的时间 第二种就是强制Hugo渲染发布时间在未来的博文，这有两种办法：  第一个是在config.toml中加入以下设置：buildFuture = true 第二个是在hugo build博客的时候，加上 --buildFuture 选项    </description>
    </item>
    
    <item>
      <title>定时任务的常见触发方式</title>
      <link>https://wenchao.ren/posts/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 24 Jul 2019 23:26:19 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F/</guid>
      <description>中间件项目中，经常会有下面的场景：
 client的定时重试 client定时向server端发心跳包 server端对client的判活 &amp;hellip;  这种其实都是在某一个时间点触发一些任务，但是当任务量很大时，怎么做比较高效呢？
比如client定时向server发心跳包，在server端如何对client进行判活呢？一般我们的做法主要有下面的几种，当任务量很大的时候我们一般都会采样环形队列/HashedWheelTimer方法。
轮询扫描 轮询扫描是最简单的处理方式，也非常的常见：
 用一个Map来记录每一个client最近一次请求时间last_packet_time 当client有请求包来到，实时更新这个Map 同时有一个线程来专门的不断扫描这个map，比如当检查client的last_packet_time是否超过30s，如果超过则进行超时处理  多timer触发  用一个Map来记录每一个client最近一次请求时间last_packet_time 当某个client有请求包来到，实时更新这个Map，并同时对这个client的请求包启动一个timer，30s之后触发 每个client的请求包对应的timer触发后，看Map中，查看这个client的last_packet_time是否超过30s，如果超过则进行超时处理  环形队列/HashedWheelTimer 这种方案简单描述如下：
 环形队列，本质是一个数组，比如30s超时，就创建一个index从0到30的环形队列 环上每一个slot是一个Set，表示：任务集合 同时还有一个Map，记录某个client落在环上的哪个slot里 同时启动一个timer，每隔1s，在上述环形队列中移动一格，移动到数组最后一个元素时候，又从第一个开始，也就是：0-&amp;gt;1-&amp;gt;2-&amp;gt;3…-&amp;gt;29-&amp;gt;30-&amp;gt;0… 有一个Current Index指针来标识刚检测过的slot  当某client有请求包到达时：
 从Map结构中，查找出这个client存储在哪一个slot里 从这个slot的Set结构中，删除这个client 将client重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的上一个slot，因为这个slot，会被timer在30s之后扫描到 更新Map，这个client对应slot的index值  哪些元素会被超时掉呢？
因为Current Index每秒种移动一个slot，这个slot对应的Set中所有client都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。
优势：
 只需要1个timer timer每1s只需要一次触发，消耗CPU很低 批量超时，Current Index扫到的slot，Set中所有元素都应该被超时掉  </description>
    </item>
    
    <item>
      <title>理解同步、异步、阻塞和非阻塞</title>
      <link>https://wenchao.ren/posts/%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/</link>
      <pubDate>Wed, 27 Mar 2019 19:42:17 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/</guid>
      <description>关于同步、异步、阻塞和非阻塞这个概念性问题，这可能是非常容易混淆的概念之一，特别是那些刚开始解除网络编程的人来说。本篇文章争取来说清楚这个问题，如果有错误之处，恳请批评指正。
写在前面 首先大家心中需要有以下的清晰认知：
 阻塞操作不等于同步（blocking operation does NOT equal to synchronous） 非阻塞操作不等于异步（non-blocking operation does NOT equal to asynchronous）  事实上，同步异步于阻塞和非阻塞没有什么直接的关联关系。
同步和异步 同步和异步关注的是 通信机制 (communication mechanism)
 同步是指在发出一个function调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到调用结果了。这个结果可能是一个正确的期望结果，也可能是因为异常原因（比如超时）导致的失败结果。换句话说，就是由调用者主动等待这个调用的结果。   Synchronous is, when we started a function call, the call will not return anything until it gets the result, the function needs to finish everything before it can give anything to us.
  异步是调用在发出之后，本次调用过程就直接返回了，并没有同时没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态变化、事件通知等机制来通知调用者，或通过回调函数处理这个调用。   Asynchronous does not need to wait for the function completes its operation, once we call it, it returns immediately without any result, the function uses callback function (or other notification method) to &amp;ldquo;notify&amp;rdquo; us to get the value after it completes execution.</description>
    </item>
    
    <item>
      <title>监控系统的模板功能</title>
      <link>https://wenchao.ren/posts/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 11 Mar 2019 12:20:55 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8A%9F%E8%83%BD/</guid>
      <description>这篇文章主要总结整理一下最近工作中两套监控系统合并过程中使用模板功能来抽象【针对应用相关的监控】 和【针对机器相关的监控】的差异。
背景 公司主要的监控系统主要是针对应用级别的，所有的指标都是属于App级别的，也就是想看某条监控指标数据，首先需要选定具体的APP。 然后公司也有一套针对机器相关的监控系统，因为机器相关的监控很多时候是以机器为维度的，也就是想查询某个机器的指标数据时 需要先指定具体的机器。同时由于公司业务的特殊性，也需要增加对多种终端类型（比如门店、货柜）的监控相关的功能。同时考虑到开发 、维护等成本等等的诸多因素，现在需要将两套监控系统合并。因此需要一套通用的模型来抽象这种问题。
其中这套模式本身并不复杂，没啥好说的。
模板功能模型 下面这个图是我当时设计的模板功能
简单描述一下这个图：
 Endpoint可以属于多个EndpointGroup EndpointGroup可以绑定多个Template, 一个Template也可以绑定到多个EndpointGroup上面 Template会包含多个Metric数据，同时也支持继承关系，也就是子模板会继承父模板的指标数据，如果父子模板中都含有同样的 Metric的话，那么子模板的会覆盖父模板的指标数据。 Endpoint也可以直接和Template来进行绑定，而不需要通过EndpointGroup Endpoint可以直接添加Metric数据，这个主要是因为目前针对App相关的监控都是属于这种情况的。  Endpoint 因为监控指标数据可能属于一个APP，也可能属于一个机器、门店、货柜、咖啡机等。所以使用了抽象的Endpoint来描述指标的归属。
EndpointGroup 含义很简单，之所以弄这个主要是为了做批处理，这样就不需要针对每一个Endpoint来进行操作了，一次可以操作一批。
Template Template其实就是一些Metric的集合，支持继承功能，继承功能其实并不是必须的，可以通过组合来实现，最后我们选择了继承 的方式，主要是考虑到针对下面的场景，继承这种方式描述起来更好一些：
所有的机器都有一些基础监控，比如针对cpu、内存的监控，我们将这些基础的指标数据使用template1来进行打包，然后如果想对所有的 dev环境的机器增加一些监控指标，这些监控指标我们使用Template2来打包
如果使用组合的方式，需要对Endpoint或者EndpointGroup绑定Template1和Template2，而如何使用继承的话，只需要绑定Template2 就好。
Metric 这个比较简单，所有监控系统的基本语义。</description>
    </item>
    
    <item>
      <title>个人认为的工作多年的开发者的3个最重要技能</title>
      <link>https://wenchao.ren/posts/%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%A4%9A%E5%B9%B4%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%843%E4%B8%AA%E6%9C%80%E9%87%8D%E8%A6%81%E6%8A%80%E8%83%BD/</link>
      <pubDate>Wed, 20 Feb 2019 20:47:33 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%A4%9A%E5%B9%B4%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%843%E4%B8%AA%E6%9C%80%E9%87%8D%E8%A6%81%E6%8A%80%E8%83%BD/</guid>
      <description>不知道你觉的工作多年的开发者最重要的技能是什么？
随着工作经历的增长，我个人越来越觉得对于开发者来说，很多时候个人的专业技能反而并不是最重要的，甚至在很多的时候是最廉价，最容易被替代的。反而是一些非专业技能确显得更加的重要。我觉的按照优先级从高到低依次为：
 业务洞察力 技术视野 非常高执行力  业务洞察力 业务洞察力是值：在当下能够做出合理的判断，清楚Team或者公司做什么事情收益最大，很多时候是 战略层面 的问题
我们经常会面临有无穷无尽的事情要做，有无穷无尽的事情可以做，但是
 我们应该先做哪个呢？ 做哪些事情的收益是最大的呢？ 做哪些事情做了和没做对公司区别没那么大呢？ 甚至哪些做哪些事情是吃力不讨好的呢？  这里不是说大家要做老油条，而是要有超前的眼光，跳出仅仅作为一个代码编写员的视角，站在更高的层次来思索事情的优先级。
那平时应该怎么做呢？
我觉的首先要有这方面的意识，其次多了解公司各个team正在做的事情，通过新闻、自己的观察、茶前饭后的闲聊、帮其他组同事排查问题时听到的等等的手段，尽可能多的获取一些公司大的层面的一些信息，然后了解公司的一些计划，公司业务的重点发展方向，业务团队经常的痛点是什么等等的。然后基于这些信息，来辅助我们做优先级判断。
技术视野 技术视野即技术选型能力，是 战术层面 的问题，在清楚做什么事情后，需要进一步解决怎么做的问题，也就是能够给出合理的技术选型方案：是完全基于开源的方案，还是基于开源二次开发的方案，还是完全自研的方案，同时要有一定的前瞻性，保持自己对业界技术风向的敏感度。但是一切都要结合公司实际发展情况，要务实不能务虚。不能盲目的追求高新技术，一定要把握好技术风险。
非常高执行力 执行力是技术落地执行层面的问题，一旦技术设计方案确定后，需要能够快速完成。一般工作多年的同事的执行力往往都是比较高的，毕竟手熟。所以要注意培养自己的前两点能力。
这3点层层递进，最重要的是先把技术战略问题思考清楚，然后再进一步解决技术战术问题，最后是快速落地执行的问题。</description>
    </item>
    
    <item>
      <title>促销系统设计</title>
      <link>https://wenchao.ren/posts/%E4%BF%83%E9%94%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 23 Jan 2019 00:19:49 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E4%BF%83%E9%94%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid>
      <description>写在前面 首先必须得说一下，我并没有实际参与过电商系统相关的业务，我一直工作的项目组做的事情和本篇文章要讲的东西完全不同。因此本篇文章仅仅是我自己平时观察和构想的一些整理，如果有不太合理的地方，希望大家指正，先谢谢大家。
文章简介 在各大电商网站上，基本时时刻刻都可以看到促销活动。相信大家基本都参与过一些促销活动。随着业务的复杂化、运营的精细化，以及品类、平台、渠道的不断丰富，各种新的促销形式也层出不穷，贯穿从商品展示、搜索、购买、支付等整个流程。虽然促销的商品本身千差万别，但是但对于促销这个事情来说，又有很多共同的地方，本篇文章希望可以归纳总结出一套设计促销系统模型的方法论出来。
促销系统介绍 如果需要给促销一个定义的话，那么促销就是：
 在某个时间范围内，对满足某些条件的用户，给予满足某些约束的商品进行一定形式的优惠
 而促销系统就是为了支撑若干个这样的促销活动而设计出来的系统。 促销规则的生效页面是购物车页面和结算页面。在结算页面比购物车页面多出的是对运费的处理，其它的信息和购物车页面的信息是一致。只有在顾客将某个产品加入购物车后，基于购物车内的产品进行计算分析才会得出折扣后的价格、赠送或其它信息。当然在具体结算的时候，也会根据用户所选择的购物车中的项目重新计算折扣后的价格、赠送等其他信息的
常见的促销活动例子：  购买的图书满100减20，满200减50 购买某商品，赠送另外一个商品 满200元任选一个赠品 某商品特价 买A商品，在买B商品，则给予一定的折扣 满多少免运费 &amp;hellip;&amp;hellip;  促销系统模型的目标  功能强大 可扩展性好 与其他系统耦合度低  促销系统模型的设计 基本的促销模型 参考资料  当当11.11：促销系统与交易系统的重构实践 Craft6.cn 电商研发方案 - 促销规则、优惠券和活动模块分析和设计  </description>
    </item>
    
    <item>
      <title>单据的设计</title>
      <link>https://wenchao.ren/posts/%E5%8D%95%E6%8D%AE%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 17 Jan 2019 19:03:55 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E5%8D%95%E6%8D%AE%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>本文主要是初步记录一下关于单据零散的想法，看看是否可以形成一套可行的方法论。
单据实体 单据这个实体，其实从抽象的层面来说，它其实描述了一次行为：
 谁，在什么时间点，用了什么样的成本，对什么目标产生了一次什么样的行为
 如果让我们来对上面这句话进行解析，其实可以发现它可以拆分为下面几块：
 谁 时间信息 成本 行为描述 行为目标  下面我们来一次分析这个问题。
谁 一般订单的发起者其实都是【用户】，当然这个用户并不一定是C端用户。而用户的信息如何描述呢？一般的公司都会有【用户中心】，或者【供应商管理系统】等等的来描述【用户】的信息。做的好的公司也会有【用户画像】
时间信息 时间信息一般分为2类：
 行为动作的产生时间  比如用户的下单时间   行为动作所带来的影响发生的时间  用户购买的商品的出库时间 用户购买的商品的送货时间 用户购买的商品的预计收货时间 前者是用户主动产生的，后者其实对用户来说是被动的。    成本信息 用户在下订单的时候往往都会消耗一定的成本，这个成本并不一定是金钱。可能是：
 金钱 积分 优惠券 &amp;hellip;  ##行为描述
行为描述主要是用来解释行为，比如：
 购买行为 退货行为  不同的行为会有不同的属性信息，比如购买行为会有购买的数量，购买服务的持续时间等。
行为目标 行为的目标可以是物理实体，比如商品（一瓶可乐），也可以是虚拟实体，比如一次服务。
 商品 服务 流量 &amp;hellip;  而具体的目标也会有一大套自己的模型和属性。比如商品的sku就是一套很经典的模型。
单据本身的信息 单据本身也需要一些自己的属性信息：
 单号 单据类型 状态机  关于单据号的设计可以很有讲究，一般会有如下的考虑：
 单据号的形式，长度 是否有业务含义  无 有   业务含义的具体信息 业务含义占单据号的长度 是否连续（可遍历） 单据创建时间 单据生成的serverIP 路由信息 分库分表的依据 其他路由形式 单据数量增长对单据号的影响 单据号长度的划分 每秒最大单据数量预估 关于路由信息也有一个需要注意的点，就是要尽量做到数据分布平衡。  单据流程 单据的流程一般有正向流程和逆向流程。考虑到解耦和业务复杂度不可控导致的变数，一般情况下建议正向和逆向分开设计和实现。然后通过单号等信息进行关联。</description>
    </item>
    
    <item>
      <title>快速的熟悉陌生的系统</title>
      <link>https://wenchao.ren/posts/%E5%BF%AB%E9%80%9F%E7%9A%84%E7%86%9F%E6%82%89%E9%99%8C%E7%94%9F%E7%9A%84%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 17 Jan 2019 18:58:28 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E5%BF%AB%E9%80%9F%E7%9A%84%E7%86%9F%E6%82%89%E9%99%8C%E7%94%9F%E7%9A%84%E7%B3%BB%E7%BB%9F/</guid>
      <description>工作和学习过程中经常会遇到陌生的系统需要去熟悉，下面是我总结的一些自己的方法论，希望对你有所帮助。
了解系统Overview 首先我们需要对系统有一个Overview的了解，了解的方式可以是自己摸索，找对应系统负责人，团队leader聊，也可以自己找wiki，文档等方法。我简单的总结了一下步骤：
 熟悉系统的定位，明确系统要解决的主要问题 如果系统有对应的UI页面，比如对于web系统，可以申请系统的权限，然后登陆系统看看系统主要有哪些菜单（一般情况下菜单其实会对于系统的功能模块），每个菜单下面都有哪些菜单项，然后浏览一下每个菜单项对应的页面有哪些按钮，哪些表格，哪些表单等。这样会对系统有哪些模块、功能有一个大概的了解。 如果你幸运的话，你可以阅读系统使用手册、设计文档、需求文档等，当然大多数情况下是没有的。这个时候你其实更多的需要上一步骤对系统的大概理解，然后结合自己的工作经验，大致猜猜系统怎么设计实现的，其实对于大多数业务系统来说，看看功能模块其实是可以猜出个七七八八的系统设计和使用的情况的。当然了对于类似中间件那些系统（比如MQ，Config，Schedule）等，其实了解起来更加的迅速，因为大家基本在日常工作过程中都使用过这些系统，所以对于系统需要提供的基本功能和如何使用都比较熟悉，可能就是在系统的设计和实现上有所差异。 了解系统的上下游。上下游都是哪些团队的哪些系统？这些团队的负责人是谁？系统和上下游系统是如何交互的？交互方式是什么，交互的时机等。 了解系统的核心数据流向。清楚一个完成的数据链路是怎么样的。 如果可以的话，自己动手在系统的dev环境或者beta环境来点一点，创建一些数据，然后走走核心数据链路。 了解系统的核心监控指标。了解清楚核心监控指标，其实便于你理解系统的核心功能，并且方便日后对系统修改的时候，看看是否对核心监控指标有影响。 了解系统的部署情况。一般一个系统都会有好几个模块（module），清楚每个模块干啥的，这些模块之间的依赖关系（比如admin模块，Server模块，client模块），模块或者系统系统如何部署的，是部署在KVM上？Kubernetes上？多少个实例？多少台Server？Server啥配置？存储用的啥？MySQL？HBase？DB数据量大致多少？存储多少个G/T? 存储增长量多少？系统的QPS大致多少？ 按照上面的步骤操作完以后，相信你一定会对系统有一个明确的了解。这个时候其实你应该可以对系统的存储模型（数据模型）猜出个七七八八了，接下来可以看看系统的存储模型了，来验证我们的猜测。  阅读系统存储模型 此处说的存储模型也可以称为是数据模型。可以是MySQL表设计（有哪些表，表之间的关联关系，表的索引是哪些，唯一索引是哪些），Hbase的存储方式（rowKey是如何设计的，列簇如何弄的，有哪些列），也可以是抽象意义上的数据模型。
阅读系统的源码 基本了解系统功能以后，知道存储模型以后，大致怎么实现其实 应该也可以猜出来了。当然了很多功能其实的实现方式会有很多种，通过阅读系统的源码我们就可以知道系统是采用的哪种方式。如果遇到和我们猜测的实现方式不一样的话，其实可以思考一下为啥不一样？两种实现方式的区别在哪，孰优孰劣。
关于阅读源码，我整理了几个注意点
 首先让系统在本地/dev/beta跑起来，最好在本地，这样其实对系统的运行环境可以更加熟悉。 先从从核心数据链路的最开始进行源码阅读，第一次阅读只需要关心核心链路，分支链路第一次阅读的时候请忽略。 对核心逻辑流程进行debug。因为设计的比较好的系统，往往接口和实现是分离的，而且会有多个实现，光看接口其实有时候根本不清楚走的哪个实现，这个时候就需要进行debug了。有时候一些方法实现的可能很不清晰，这个时候通过debug，或者写main方法，单元测试等手段来了解。 开业手动画出系统核心流程的关键类的调用关系 阅读系统非核心逻辑代码 尝试讲给系统的开发人员，确认你理解的是正确的。对一些感觉设计不合理的点，咨询当时那么设计的原因  解决自己的疑惑，确认可优化点 一般情况下，我们在阅读完系统代码之后，会有自己的疑惑，也会发现一些设计不合理的点（虽然可能这个设计在当时的情况下是合理的），我们可以提出自己的优化方案，然后找对应系统的产品、开发、负责人确认。
结语 如果你完全按照上面的方式做了，还是没有对某个系统熟悉的话，那么就只能找对应系统的产品、开发、负责人具体咨询了。</description>
    </item>
    
  </channel>
</rss>
