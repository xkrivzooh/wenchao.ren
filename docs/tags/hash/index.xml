<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hash on 被遗忘的博客</title>
    <link>https://wenchao.ren/tags/hash/</link>
    <description>Recent content in hash on 被遗忘的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 27 Feb 2019 12:37:11 +0000</lastBuildDate><atom:link href="https://wenchao.ren/tags/hash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一致性哈希</title>
      <link>https://wenchao.ren/posts/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</link>
      <pubDate>Wed, 27 Feb 2019 12:37:11 +0000</pubDate>
      
      <guid>https://wenchao.ren/posts/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</guid>
      <description>本文谈谈一致性哈希，一致性哈希作为「负载均衡」中比较常见的一种实现，经常会有意无意的被大家使用到。我希望通过这篇文章可以使得你完全明白：
 一致性哈希要解决的问题 一致性哈希的原理 一致性哈希的优点 一致性哈希的不适用场景 如何手动实现一致性哈希 常见开源代码中的一致性哈希实现  一致性哈希要优化的问题 一致性哈希要解决的问题，或者说目标，其实用一句话概括就是：在hash value区间有限并且可能会发生变化的情况下，相同的hash key尽可能得到同一个hash value。
上面短短的一句话，我们可以得到一些重要信息：
一致性哈希的原理 上面短短的
一致性哈希负载均衡需要保证的是“相同的请求尽可能落到同一个服务器上”，注意这短短的一句描述，却包含了相当大的信息量。“相同的请求” — 什么是相同的请求？一般在使用一致性哈希负载均衡时，需要指定一个 key 用于 hash 计算
一致性哈希的优点 相比于传统的「取模」哈希，一致性哈希减少了因为服务节点变更导致的key的映射关系失效的数量
一致性哈希的不适用场景 </description>
    </item>
    
  </channel>
</rss>
