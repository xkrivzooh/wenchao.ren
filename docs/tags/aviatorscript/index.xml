<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AviatorScript on 被遗忘的博客</title>
    <link>https://wenchao.ren/tags/aviatorscript/</link>
    <description>Recent content in AviatorScript on 被遗忘的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 08 May 2021 14:11:09 +0800</lastBuildDate><atom:link href="https://wenchao.ren/tags/aviatorscript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AviatorScript ClassDefiner源码解析</title>
      <link>https://wenchao.ren/posts/aviatorscript-classdefiner%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 08 May 2021 14:11:09 +0800</pubDate>
      
      <guid>https://wenchao.ren/posts/aviatorscript-classdefiner%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
      <description>在AviatorScript的内部实现机制中，需要将AviatorScript脚本翻译为可执行的java代码，所以会设计到「类的动态生成」和「类的加载」这2个功能。 而其中关于「类的加载」这部分的功能是在com.googlecode.aviator.code.asm.ClassDefiner中实现的, 在ASMCodeGenerator中通过下面的方式来使用：
Class&amp;lt;?&amp;gt; defineClass = ClassDefiner.defineClass(this.className, Expression.class, bytes, this.classLoader);  而这个defineClass方法的定义如下：
public static final Class&amp;lt;?&amp;gt; defineClass(final String className, final Class&amp;lt;?&amp;gt; clazz, final byte[] bytes, final AviatorClassLoader classLoader) throws NoSuchFieldException, IllegalAccessException { if (!preferClassLoader &amp;amp;&amp;amp; DEFINE_CLASS_HANDLE != null) { try { Class&amp;lt;?&amp;gt; defineClass = (Class&amp;lt;?&amp;gt;) DEFINE_CLASS_HANDLE.invokeExact(clazz, bytes, EMPTY_OBJS); return defineClass; } catch (Throwable e) { // fallback to class loader mode. if (errorTimes++ &amp;gt; 10000) { preferClassLoader = true; } return defineClassByClassLoader(className, bytes, classLoader); } } else { return defineClassByClassLoader(className, bytes, classLoader); } }  因为上下文中preferClassLoader的定义是：</description>
    </item>
    
    <item>
      <title>AviatorScript编译执行流程</title>
      <link>https://wenchao.ren/posts/aviatorscript%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 07 May 2021 14:11:09 +0800</pubDate>
      
      <guid>https://wenchao.ren/posts/aviatorscript%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid>
      <description>本篇文章通过AviatorScript工程自带的一个示例，来简单说明一下AviatorScript的执行流程:
 初始化Aviator的核心数据结构 读取AviatorScript脚本内容，做语法树解析，并通过ASM翻译为java字节码，然后通过classLoader做类加载，构建Expression实例。 通过触发Exception#execute方法来触发脚本执行。  示例程序 本部分继续以下面的示例来说明，这个实例在AviatorScript的工程中可以找到:
public class RunScriptExample { public static void main(final String[] args) throws Exception { // Enable java method invocation by reflection. AviatorEvaluator.getInstance() .setFunctionMissing(JavaMethodReflectionFunctionMissing.getInstance()); // You can trry to test every script in examples folder by changing the file name. Expression exp = AviatorEvaluator.getInstance().compileScript(&amp;quot;examples/hello.av&amp;quot;); exp.execute(); } }  在这个实例程序中，AviatorEvaluator.getInstance()是单例模式的一种实现，用来获取AviatorEvaluatorInstance实例。
AviatorEvaluatorInstance初始化流程 在AviatorEvaluator中通过单例模式创建了AviatorEvaluatorInstance的实例。
public static AviatorEvaluatorInstance newInstance() { return new AviatorEvaluatorInstance(); } private static class StaticHolder { private static AviatorEvaluatorInstance INSTANCE = new AviatorEvaluatorInstance(); }  下面是AviatorEvaluatorInstance的构造函数：</description>
    </item>
    
  </channel>
</rss>
